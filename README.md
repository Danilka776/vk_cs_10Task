**Практическое задание по теме «Основы безопасности инфраструктуры»**

Все описанные уязвимости исправлены в файле lab-deploy_bugFix.yml.

1) Жёстко заданные секреты (hard-coded secrets):
- строка 8:  
app_password: "Sup3rS3cr3tP@ssw0rd123" <br>
Пароль хранится в открытом виде в playbook
- строка 81: <br>
Your secret token: {{ secret_token.stdout }} <br>
в HTML встраивается «секретный» токен; после генерации он оказывается жёстко записан в статическом файле, откуда любой пользователь может его скопировать. <br> <br>
Почему опасно: репозиторий Ansible обычно лежит в системе контроля версий (гит, например), попадает в CI/CD‑логи и бэкапы. Утечка даёт злоумышленнику сразу root‑доступ (пароль + sudo без пароля) и токен, который можно применить для неавторизованных запросов. Исправить можно путем хранения шифрованных паролей или с использованием Ansible Vault или использовать внешние хранилища секретов. В обновленный код добавлн пароль из vault. 


2) На строках 40 и 41 происходит полное отключение firewall и игнорирование ошибок. <br>
Отключение фаервола открывает все порты для подключения. Это сильно повышает риск: без активного фаервола все сетевые порты остаются открытыми, что предоставляет атакующему больше векторов атаки на сервер. Вместо полного отключения стоит настроить необходимые правила явно – например, разрешать только нужные порты (nginx чаще всего использует 80/443) и блокировать всё остальное. Если нужно временно ограничить доступ, можно устанавливать конкретные правила разрешения/запрета, а не выключать UFW целиком. <br> <br>
Кроме того, ignore_errors: yes подавляет любые ошибки. Это тоже опасно: если команда отключения брандмауэра или какая-то другая задача завершается с ошибкой, playbook продолжит работу, хотя защита может не выключена или выключена некорректно. Получается, что мы не можем предсказать в каком состоянии находится система. Обнаружить ошибку в такой ситуации сложно, так как вывод console завален игнорируемыми ошибками. Вместо ignore_errors лучше применять более тонкую обработку: использовать конструкцию block/rescue для отслеживания и реагирования на ошибки. Таким образом playbook не будет молча игнорировать сбои и даст возможность приостанавливать выполнение при возникновении проблемы.

3) В playbook используется get_url для загрузки файла приложения, но без параметра checksum. Это небезопасно, поскольку файл скачивается напрямую из сети и playbook не проверяет его целостность и подлинность. Злоумышленник может подменить бинарь, внедрив backdoor, и без контрольной суммы это останется незамеченным. Рекомендуется указывать проверку SHA256. Проверка контольной суммы представлена в исправленном файле lab-deploy_bugFix.yml. Так Ansible вычислит SHA256 скачанного файла и сравнит с ожидаемым. Если хэши не совпадут (файл повреждён или подменён), загрузка будет прервана, и плейбук сообщит об ошибке. Это обеспечивает гарантию того, что получен именно тот файл, который ожидался.

4) В playbook используется Docker-образ nginx:1.18.0. Эта версия является зафиксированной и может содержать известные уязвимости. Так как релизу больше 5 лет, в нем найдено несколько CVE, которые были исправлены в последующих версиях. В целом, контейнерные образы нужно регулярно обновлять и сканировать на CVE. Например, можно использовать инструменты вроде Trivy, Clair, Snyk или встроенные средства регистров, чтобы проверять базовый образ на наличие известных проблем. Если найдены критичные уязвимости, следует обновить тег образа до безопасной версии (nginx:stable или конкретной новой версии) и протестировать приложение. Также полезно использовать минимальные образы (например, nginx:alpine) и регулярно перезапускать деплоймент с новыми версиями образа.

5) На строке 96: mode 0777 даёт полные права (чтение, запись, выполнение) всем пользователям и группам на этом каталоге. Это небезопасно, так как любой локальный пользователь или процесс сможет записать, изменить или исполнить файлы в этой директории. В условиях общего или даже виртуального сервера это создаёт риск внедрения вредоносных скриптов(включая темплейты HTML, что позволяет внести XSS / RCE), перезаписи содержимого приложения и прочих атак. Операционная система дистрибутивов Linux обычно не проектируется под такую вседоступность – это нарушение принципа наименьших привилегий. Правильнее установить более строгие права, например 0755 (только владелец может записывать, остальные – читать и заходить) или даже 0700, если доступ нужен только одному сервисному пользователю.

6) В playbook генерируется «секретный» токен (у меня e1be12703011165c0c61ec6e514194bb) и вставляется прямо в HTML-файл (вероятно, для фронтенда). Это небезопасно, так как любая информация, закодированная в статическом HTML/JS, полностью доступна конечному пользователю и любому наблюдателю. Если этот токен предназначен для доступа к защищённому API или службе, то с ним можно полностью скомпрометировать безопасность приложения – злоумышленник может открыть код страницы и скопировать секрет. Более надёжный подход – не распространять секреты на фронтенд вообще. Вместо этого токены стоит хранить на сервере (backend) и передавать клиенту токены с коротким сроком действия по защищённым каналам (например, через защищённые cookie или отдельный endpoint), либо вовсе обрабатывать запросы с backend-а (чтобы фронту вообще не нужен был прямой доступ к токену). Если же веб-приложение требует аутентификацию, лучше использовать протоколы OAuth или JWT с ротацией и безопасным хранением ключей на сервере, а в HTML/JS генерировать ненадёжные персистентные токены (например, одноразовые session-токены или CSRF-токены), которые не раскрывают никаких секретов. В Ansible можно, например, сделать так: не генерировать токен прямо в шаблоне index.html, а сохранить его в защищённом файле конфигурации и передавать фронту только ID сеанса. В итоге секреты управления приложением останутся на сервере и не попадут в клиенто-видимый код, что значительно снизит риск их компрометации.